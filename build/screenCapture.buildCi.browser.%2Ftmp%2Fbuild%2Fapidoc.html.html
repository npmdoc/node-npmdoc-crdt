<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/dominictarr/crdt">crdt (v3.6.4)</a>
</h1>
<h4>Commutative Replicated Data Types for easy distributed/collaborative apps</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt">module crdt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.crdt">
            function <span class="apidocSignatureSpan"></span>crdt
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc">
            function <span class="apidocSignatureSpan">crdt.</span>Doc
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Row">
            function <span class="apidocSignatureSpan">crdt.</span>Row
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq">
            function <span class="apidocSignatureSpan">crdt.</span>Seq
            <span class="apidocSignatureSpan">(doc, key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set">
            function <span class="apidocSignatureSpan">crdt.</span>Set
            <span class="apidocSignatureSpan">(doc, key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.createStream">
            function <span class="apidocSignatureSpan">crdt.</span>createStream
            <span class="apidocSignatureSpan">(doc, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_">
            function <span class="apidocSignatureSpan">crdt.</span>super_
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.sync">
            function <span class="apidocSignatureSpan">crdt.</span>sync
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">crdt.</span>Doc.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">crdt.</span>Row.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">crdt.</span>Seq.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">crdt.</span>Set.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">crdt.</span>super_.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.Doc">module crdt.Doc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.Doc">
            function <span class="apidocSignatureSpan">crdt.</span>Doc
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.Row">
            function <span class="apidocSignatureSpan">crdt.Doc.</span>Row
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.Seq">
            function <span class="apidocSignatureSpan">crdt.Doc.</span>Seq
            <span class="apidocSignatureSpan">(doc, key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.Set">
            function <span class="apidocSignatureSpan">crdt.Doc.</span>Set
            <span class="apidocSignatureSpan">(doc, key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.createStream">
            function <span class="apidocSignatureSpan">crdt.Doc.</span>createStream
            <span class="apidocSignatureSpan">(doc, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.super_">
            function <span class="apidocSignatureSpan">crdt.Doc.</span>super_
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.sync">
            function <span class="apidocSignatureSpan">crdt.Doc.</span>sync
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.Doc.prototype">module crdt.Doc.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype._add">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>_add
            <span class="apidocSignatureSpan">(id, source, change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.add">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>add
            <span class="apidocSignatureSpan">(initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.applyUpdate">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>applyUpdate
            <span class="apidocSignatureSpan">(update, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.createSeq">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>createSeq
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.createSet">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>createSet
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.get">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>get
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.history">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>history
            <span class="apidocSignatureSpan">(sources)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.rm">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>rm
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.set">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>set
            <span class="apidocSignatureSpan">(id, change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.timeUpdated">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>timeUpdated
            <span class="apidocSignatureSpan">(row, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Doc.prototype.toJSON">
            function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.Row">module crdt.Row</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Row.Row">
            function <span class="apidocSignatureSpan">crdt.</span>Row
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Row.super_">
            function <span class="apidocSignatureSpan">crdt.Row.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.Row.prototype">module crdt.Row.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Row.prototype._set">
            function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>_set
            <span class="apidocSignatureSpan">(changes, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Row.prototype.get">
            function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Row.prototype.set">
            function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>set
            <span class="apidocSignatureSpan">(changes, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Row.prototype.toJSON">
            function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Row.prototype.validate">
            function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>validate
            <span class="apidocSignatureSpan">(changes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.Seq">module crdt.Seq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.Seq">
            function <span class="apidocSignatureSpan">crdt.</span>Seq
            <span class="apidocSignatureSpan">(doc, key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.super_">
            function <span class="apidocSignatureSpan">crdt.Seq.</span>super_
            <span class="apidocSignatureSpan">(doc, key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.Seq.prototype">module crdt.Seq.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.after">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>after
            <span class="apidocSignatureSpan">(obj, after)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.asArray">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>asArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.at">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>at
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.before">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>before
            <span class="apidocSignatureSpan">(obj, before)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.first">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.indexOf">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.last">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.length">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.next">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>next
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.pop">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.prev">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>prev
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.push">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>push
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.shift">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Seq.prototype.unshift">
            function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>unshift
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.Set">module crdt.Set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.Set">
            function <span class="apidocSignatureSpan">crdt.</span>Set
            <span class="apidocSignatureSpan">(doc, key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.super_">
            function <span class="apidocSignatureSpan">crdt.Set.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.Set.prototype">module crdt.Set.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.prototype.asArray">
            function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>asArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.prototype.each">
            function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>each
            <span class="apidocSignatureSpan">(iter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.prototype.forEach">
            function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>forEach
            <span class="apidocSignatureSpan">(iter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.prototype.get">
            function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>get
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.prototype.has">
            function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>has
            <span class="apidocSignatureSpan">(row)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.prototype.onEach">
            function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>onEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.Set.prototype.toJSON">
            function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.super_">module crdt.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.super_">
            function <span class="apidocSignatureSpan">crdt.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.filter">
            function <span class="apidocSignatureSpan">crdt.super_.</span>filter
            <span class="apidocSignatureSpan">(update, sources)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.timestamp">
            function <span class="apidocSignatureSpan">crdt.super_.</span>timestamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.updateIsRecent">
            function <span class="apidocSignatureSpan">crdt.super_.</span>updateIsRecent
            <span class="apidocSignatureSpan">(update, sources)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.crdt.super_.prototype">module crdt.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype._update">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>_update
            <span class="apidocSignatureSpan">(update)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.applyUpdate">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>applyUpdate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.clone">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.createReadStream">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>createReadStream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.createStream">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>createStream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.createWriteStream">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>createWriteStream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.dispose">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.history">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>history
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.localUpdate">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>localUpdate
            <span class="apidocSignatureSpan">(trx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.crdt.super_.prototype.setId">
            function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>setId
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt" id="apidoc.module.crdt">module crdt</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.crdt" id="apidoc.element.crdt.crdt">
        function <span class="apidocSignatureSpan"></span>crdt
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doc(id) {
  if (!(this instanceof Doc)) return new Doc(id)
  //the id of the doc refers to the instance.
  //that is, to the node.
  //it's used to identify a node
//  this.id = id || '#' + Math.round(Math.random()*1000)
  this.rows = {}
  this.hist = {}
  this.sets = new EventEmitter() //for tracking membership of sets.
  this.setMaxListeners(Infinity)
  this.sets.setMaxListeners(Infinity)
  Scuttlebutt.call(this, id)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc" id="apidoc.element.crdt.Doc">
        function <span class="apidocSignatureSpan">crdt.</span>Doc
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doc(id) {
  if (!(this instanceof Doc)) return new Doc(id)
  //the id of the doc refers to the instance.
  //that is, to the node.
  //it's used to identify a node
//  this.id = id || '#' + Math.round(Math.random()*1000)
  this.rows = {}
  this.hist = {}
  this.sets = new EventEmitter() //for tracking membership of sets.
  this.setMaxListeners(Infinity)
  this.sets.setMaxListeners(Infinity)
  Scuttlebutt.call(this, id)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  process.exit(1)
}

//auto node attempts to create a TCP server on PORT
//if PORT is in use (by another autonode)
//connect as a client.

var m = new crdt.<span class="apidocCodeKeywordSpan">Doc</span>()

autonode(function (stream) {
  stream
    .pipe(m.createStream())
    .pipe(stream)
}).listen(4242)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Row" id="apidoc.element.crdt.Row">
        function <span class="apidocSignatureSpan">crdt.</span>Row
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Row(id) {
  this.id = id
  this.state = {id: id}
  this.setMaxListeners(Infinity)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq" id="apidoc.element.crdt.Seq">
        function <span class="apidocSignatureSpan">crdt.</span>Seq
        <span class="apidocSignatureSpan">(doc, key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Seq(doc, key, val) {
  if(key == '__proto__')
    throw new Error('__proto__ is invalid key')

  Set.call(this, doc, key, val)

  if (typeof key !== 'string') {
    key = null
  }

  var seq = this
  this.on('changes', function (row, changes) {
    if(!changes._sort) return
    sort(seq._array)
    //check if there is already an item with this sort key.
    var prev =
    find(seq._array, function (other) {
      return other != row &amp;&amp; other.get('_sort') == row.get('_sort')
    })

    //nudge it forward if it has the same key.
    if(prev)
      seq.insert(row, prev, seq.next(row))
    else
      seq.emit('move', row)
  })
  this.insert = function (obj, before, after) {

    before = toKey(this.get(before) || '!')
    after  = toKey(this.get(after)  || '~')

    //must get id from the doc,
    //because may be moving this item into this set.
    if('string' === typeof obj)
      obj = doc.rows[obj]

    var _sort =
       between.between(before, after )
     + between.randstr(3) //add a random tail so it's hard
                    //to concurrently add two items with the
                    //same sort.

    var r, changes
    if(obj instanceof Row) {
      r = obj
      changes = {_sort: _sort}
      if (key &amp;&amp; r.get(key) != val) {
        changes[key] = val
      }
      r.set(changes)
    } else {
      obj._sort = _sort
      if (key) {
        obj[key] = val
      }
      r = doc.set(id(obj), obj)
    }
    sort(this._array)
    return r
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Set" id="apidoc.element.crdt.Set">
        function <span class="apidocSignatureSpan">crdt.</span>Set
        <span class="apidocSignatureSpan">(doc, key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Set(doc, key, value) {
  var array = this._array = []
  var rows = this.rows =  {}
  var set = this
  var filter

  if ('function' === typeof key) {
    filter = this.filter = key
    key = null
  } else {
    //DO NOT CHANGE once you have created the set.
    if(key === '__proto__') throw new Error('__proto__ is illegal key')
    this.key = key
    this.value = value
  }

  function add(row) {
    if (rows[row.id]) {
      return
    }

    array.push(row)
    rows[row.id] = row
    set.emit('add', row)

    function remove (_, changed) {
      if ((key &amp;&amp; row.state[key] === value) ||
          (filter &amp;&amp; filter(row.state))
      ) {
        set.emit('changes', row, changed)
        return
      }
      delete rows[row.id]
      var i = array.indexOf(row)
      if(~i) array.splice(i, 1)
      set.emit('changes', row, changed)
      set.emit('remove', row)
      row.removeListener('changes', remove)
    }

    row.on('changes', remove)

  }

  if (!filter) {
    doc.sets.on(key, function (row, changed) {
      if(changed[key] !== value) return
      add(row)
    })
  } else {
    doc.on('create', function (row) {
      if (filter(row.state)) {
        add(row)
      }
    })
  }


  this.rm = this.remove = function (row) {
    row = this.get(row)
    if(!row) return
    if (key) {
      return row.set(key, null)
    } else {
      throw new Error("Set cannot remove rows with arbitary filters")
    }
  }

  for(var id in doc.rows) {
    var row = doc.get(id)
    if (key &amp;&amp; row.get(key) === value) {
      add(row)
    } else if (filter &amp;&amp; filter(row.state)) {
      add(row)
    }
  }

  this.setMaxListeners(Infinity)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
it relys on the CRDT deciding to emit stream on next tick.
and emptying the queue.

(those are the two bugs I discovered writing this)
*/


var a = new crdt.<span class="apidocCodeKeywordSpan">Set</span>('set')
var as = crdt.createStream(a)
var b = new crdt.Set('set')
var bs = crdt.createStream(b)

function rand(of) {
var i = Math.floor(Math.random() * (of.length || of))
return of[i] || i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.createStream" id="apidoc.element.crdt.createStream">
        function <span class="apidocSignatureSpan">crdt.</span>createStream
        <span class="apidocSignatureSpan">(doc, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createStream = function (doc, opts) {
  return doc.createStream(opts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.sync             = sync
exports.Set              = require('./set')
exports.Seq              = require('./seq')

exports.Doc = exports

function sync(a, b) {
var as = a.<span class="apidocCodeKeywordSpan">createStream</span>()
var bs = b.createStream()
return as.pipe(bs).pipe(as)
}


exports.createStream = function (doc, opts) {
return doc.createStream(opts)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_" id="apidoc.element.crdt.super_">
        function <span class="apidocSignatureSpan">crdt.</span>super_
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scuttlebutt(opts) {

  if(!(this instanceof Scuttlebutt)) return new Scuttlebutt(opts)
  var id = 'string' === typeof opts ? opts : opts &amp;&amp; opts.id
  this.sources = {}
  this.setMaxListeners(Number.MAX_VALUE)
  //count how many other instances we are replicating to.
  this._streams = 0
  if(opts &amp;&amp; opts.sign &amp;&amp; opts.verify) {
    this.setId(opts.id || opts.createId())
    this._sign   = opts.sign
    this._verify = opts.verify
  } else {
    this.setId(id || u.createId())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.sync" id="apidoc.element.crdt.sync">
        function <span class="apidocSignatureSpan">crdt.</span>sync
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sync(a, b) {
  var as = a.createStream()
  var bs = b.createStream()
  return as.pipe(bs).pipe(as)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var crdt = require('..')
var a    = require('assertions')

var doc = new crdt.Doc()
var hoc = new crdt.Doc()
var loc = new crdt.Doc()
doc.sync = hoc.sync = loc.sync = true
var ls = crdt.<span class="apidocCodeKeywordSpan">sync</span>(doc, hoc)
var hs = crdt.sync(doc, loc)

//what happens if the streams are connected in a loop?
//that is not allowed.
//because createStream will not reemit
//written data, because it expects the stream
//to pipe back to the source.
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.Doc" id="apidoc.module.crdt.Doc">module crdt.Doc</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.Doc.Doc" id="apidoc.element.crdt.Doc.Doc">
        function <span class="apidocSignatureSpan">crdt.</span>Doc
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doc(id) {
  if (!(this instanceof Doc)) return new Doc(id)
  //the id of the doc refers to the instance.
  //that is, to the node.
  //it's used to identify a node
//  this.id = id || '#' + Math.round(Math.random()*1000)
  this.rows = {}
  this.hist = {}
  this.sets = new EventEmitter() //for tracking membership of sets.
  this.setMaxListeners(Infinity)
  this.sets.setMaxListeners(Infinity)
  Scuttlebutt.call(this, id)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  process.exit(1)
}

//auto node attempts to create a TCP server on PORT
//if PORT is in use (by another autonode)
//connect as a client.

var m = new crdt.<span class="apidocCodeKeywordSpan">Doc</span>()

autonode(function (stream) {
  stream
    .pipe(m.createStream())
    .pipe(stream)
}).listen(4242)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.Row" id="apidoc.element.crdt.Doc.Row">
        function <span class="apidocSignatureSpan">crdt.Doc.</span>Row
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Row(id) {
  this.id = id
  this.state = {id: id}
  this.setMaxListeners(Infinity)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.Seq" id="apidoc.element.crdt.Doc.Seq">
        function <span class="apidocSignatureSpan">crdt.Doc.</span>Seq
        <span class="apidocSignatureSpan">(doc, key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Seq(doc, key, val) {
  if(key == '__proto__')
    throw new Error('__proto__ is invalid key')

  Set.call(this, doc, key, val)

  if (typeof key !== 'string') {
    key = null
  }

  var seq = this
  this.on('changes', function (row, changes) {
    if(!changes._sort) return
    sort(seq._array)
    //check if there is already an item with this sort key.
    var prev =
    find(seq._array, function (other) {
      return other != row &amp;&amp; other.get('_sort') == row.get('_sort')
    })

    //nudge it forward if it has the same key.
    if(prev)
      seq.insert(row, prev, seq.next(row))
    else
      seq.emit('move', row)
  })
  this.insert = function (obj, before, after) {

    before = toKey(this.get(before) || '!')
    after  = toKey(this.get(after)  || '~')

    //must get id from the doc,
    //because may be moving this item into this set.
    if('string' === typeof obj)
      obj = doc.rows[obj]

    var _sort =
       between.between(before, after )
     + between.randstr(3) //add a random tail so it's hard
                    //to concurrently add two items with the
                    //same sort.

    var r, changes
    if(obj instanceof Row) {
      r = obj
      changes = {_sort: _sort}
      if (key &amp;&amp; r.get(key) != val) {
        changes[key] = val
      }
      r.set(changes)
    } else {
      obj._sort = _sort
      if (key) {
        obj[key] = val
      }
      r = doc.set(id(obj), obj)
    }
    sort(this._array)
    return r
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.Set" id="apidoc.element.crdt.Doc.Set">
        function <span class="apidocSignatureSpan">crdt.Doc.</span>Set
        <span class="apidocSignatureSpan">(doc, key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Set(doc, key, value) {
  var array = this._array = []
  var rows = this.rows =  {}
  var set = this
  var filter

  if ('function' === typeof key) {
    filter = this.filter = key
    key = null
  } else {
    //DO NOT CHANGE once you have created the set.
    if(key === '__proto__') throw new Error('__proto__ is illegal key')
    this.key = key
    this.value = value
  }

  function add(row) {
    if (rows[row.id]) {
      return
    }

    array.push(row)
    rows[row.id] = row
    set.emit('add', row)

    function remove (_, changed) {
      if ((key &amp;&amp; row.state[key] === value) ||
          (filter &amp;&amp; filter(row.state))
      ) {
        set.emit('changes', row, changed)
        return
      }
      delete rows[row.id]
      var i = array.indexOf(row)
      if(~i) array.splice(i, 1)
      set.emit('changes', row, changed)
      set.emit('remove', row)
      row.removeListener('changes', remove)
    }

    row.on('changes', remove)

  }

  if (!filter) {
    doc.sets.on(key, function (row, changed) {
      if(changed[key] !== value) return
      add(row)
    })
  } else {
    doc.on('create', function (row) {
      if (filter(row.state)) {
        add(row)
      }
    })
  }


  this.rm = this.remove = function (row) {
    row = this.get(row)
    if(!row) return
    if (key) {
      return row.set(key, null)
    } else {
      throw new Error("Set cannot remove rows with arbitary filters")
    }
  }

  for(var id in doc.rows) {
    var row = doc.get(id)
    if (key &amp;&amp; row.get(key) === value) {
      add(row)
    } else if (filter &amp;&amp; filter(row.state)) {
      add(row)
    }
  }

  this.setMaxListeners(Infinity)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
it relys on the CRDT deciding to emit stream on next tick.
and emptying the queue.

(those are the two bugs I discovered writing this)
*/


var a = new crdt.<span class="apidocCodeKeywordSpan">Set</span>('set')
var as = crdt.createStream(a)
var b = new crdt.Set('set')
var bs = crdt.createStream(b)

function rand(of) {
var i = Math.floor(Math.random() * (of.length || of))
return of[i] || i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.createStream" id="apidoc.element.crdt.Doc.createStream">
        function <span class="apidocSignatureSpan">crdt.Doc.</span>createStream
        <span class="apidocSignatureSpan">(doc, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createStream = function (doc, opts) {
  return doc.createStream(opts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.sync             = sync
exports.Set              = require('./set')
exports.Seq              = require('./seq')

exports.Doc = exports

function sync(a, b) {
var as = a.<span class="apidocCodeKeywordSpan">createStream</span>()
var bs = b.createStream()
return as.pipe(bs).pipe(as)
}


exports.createStream = function (doc, opts) {
return doc.createStream(opts)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.super_" id="apidoc.element.crdt.Doc.super_">
        function <span class="apidocSignatureSpan">crdt.Doc.</span>super_
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scuttlebutt(opts) {

  if(!(this instanceof Scuttlebutt)) return new Scuttlebutt(opts)
  var id = 'string' === typeof opts ? opts : opts &amp;&amp; opts.id
  this.sources = {}
  this.setMaxListeners(Number.MAX_VALUE)
  //count how many other instances we are replicating to.
  this._streams = 0
  if(opts &amp;&amp; opts.sign &amp;&amp; opts.verify) {
    this.setId(opts.id || opts.createId())
    this._sign   = opts.sign
    this._verify = opts.verify
  } else {
    this.setId(id || u.createId())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.sync" id="apidoc.element.crdt.Doc.sync">
        function <span class="apidocSignatureSpan">crdt.Doc.</span>sync
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sync(a, b) {
  var as = a.createStream()
  var bs = b.createStream()
  return as.pipe(bs).pipe(as)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var crdt = require('..')
var a    = require('assertions')

var doc = new crdt.Doc()
var hoc = new crdt.Doc()
var loc = new crdt.Doc()
doc.sync = hoc.sync = loc.sync = true
var ls = crdt.<span class="apidocCodeKeywordSpan">sync</span>(doc, hoc)
var hs = crdt.sync(doc, loc)

//what happens if the streams are connected in a loop?
//that is not allowed.
//because createStream will not reemit
//written data, because it expects the stream
//to pipe back to the source.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.Doc.prototype" id="apidoc.module.crdt.Doc.prototype">module crdt.Doc.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype._add" id="apidoc.element.crdt.Doc.prototype._add">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>_add
        <span class="apidocSignatureSpan">(id, source, change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_add = function (id, source, change) {

  var doc = this

  if(id === '__proto__')
    throw new Error('__proto__ is illegial id')
  if(this.rows[id])
    return this.rows[id]

  var r = id instanceof Row ? id : new Row(id)
  this.rows[r.id] = r

  function track (changes, source) {
    //console.log(changes, source)
    doc.localUpdate([r.id, changes])
  }

  r.on('preupdate', track)

  r.on('remove', function () {
    r.removeAllListeners('preupdate')
  })

  r._new = true
  return r
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

}

Doc.prototype.add = function (initial) {
var id = initial.id === undefined ? createId() : initial.id
if(id === '__proto__')
  throw new Error('__proto__ is illegial id')
var r = this.<span class="apidocCodeKeywordSpan">_add</span>(id, 'local')
r._set(initial, 'local')
return r
}

Doc.prototype._add = function (id, source, change) {

var doc = this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.add" id="apidoc.element.crdt.Doc.prototype.add">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>add
        <span class="apidocSignatureSpan">(initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (initial) {
  var id = initial.id === undefined ? createId() : initial.id
  if(id === '__proto__')
    throw new Error('__proto__ is illegial id')
  var r = this._add(id, 'local')
  r._set(initial, 'local')
  return r
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(row instanceof HTMLElement) return row
  if(id)
    el = document.getElementById(id)
  if(!el) {
    var el = document.createElement('div')
    el.setAttribute('id', id)
  }
  el.classList.<span class="apidocCodeKeywordSpan">add</span>('row')
  return el
}

function css () {

return '                 \
.row {                   \
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.applyUpdate" id="apidoc.element.crdt.Doc.prototype.applyUpdate">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>applyUpdate
        <span class="apidocSignatureSpan">(update, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyUpdate = function (update, source) {

  //apply an update to a row.
  //take into account histroy.
  //and insert the change into the correct place.
  if(!(Array.isArray(update[0])
    &amp;&amp; 'string' === typeof update[0][0]
  )) return this.emit('invalid', new Error('invalid update'))

  var id      = update[0][0]
  var changes = update[0][1]
  var timestamp = update[1]
  var from    = update[2]

  if(id === '__proto__')
    return this.emit('invalid', new Error('__proto__ is illegial id'))

  var changed = {}

  var row = this._add(id, source)
  var hist = this.hist[id] = this.hist[id] || {}
  var emit = false, oldnews = false


  //remember the most recent update from each node.
  //now handled my scuttlebutt.
//  if(!row.validate(changes)) return

  if (changes === null) {

    // clean up the history
    for(var key in row.state) {
      if(row.state.hasOwnProperty(key)) {
          if(!hist[key] || order(hist[key], update) &lt; 0) {
            if(hist[key]) this.emit('_remove', hist[key])
            hist[key] = [ null, update[1], update[2]]
            emit = true
          }
      }
    }

    // remove from all sets that contain row
    for (var setId in this.sets) {
      var isSet = setId.indexOf(':') &gt; 0
      var set = this.sets[setId]
      var setContainsRow = isSet &amp;&amp; set &amp;&amp; set.get(row.id)
      if (setContainsRow) set.rm(row)
    }

    // delete from the doc rows
    delete this.rows[id]
    row.emit('removed')
    this.emit('remove', row)
  }
  else {
    var maybe = []
    for(var key in changes) {
      if(changes.hasOwnProperty(key)) {
        var value = changes[key]
        if(!hist[key] || order(hist[key], update) &lt; 0) {
          if(hist[key] &amp;&amp; !~maybe.indexOf(hist[key]))
            maybe.push(hist[key])
          hist[key] = update
          changed[key] = value
          emit = true
        }
      }
    }
    var h = this.history()
    var self = this
    maybe.forEach(function (e) {
      if(!~h.indexOf(e))
        self.emit('_remove', e)
    })
  }

//  probably, there may be mulitple sets that listen to the same key,
//  but activate on different values...
//
//  hang on, in the mean time, I will probably only be managing n &lt; 10 sets.
//  at once,

  merge(row.state, changed)
  for(var k in changed)
    this.sets.emit(k, row, changed)

  if(!emit) return

  if(row._new) {
    this.emit('add', row)
    this.emit('create', row) //alias
    row._new = false
  }
  this.emit('_update', update)
  row.emit('update', update, changed)
  row.emit('changes', changes, changed)
  row.emit('change', changed) //installing this in paralel, so tests still pass.
  //will depreciate the old way later.
  this.emit('update', update, source)   //rename this event to 'data' or 'diff'?
  this.emit('row_update', row)          //rename this event to 'update'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // check if this message is older than
  // the value we already have.
  // do nothing if so
  // emit an 'old_data' event because i'll want to track how many
  // unnecessary messages are sent.

  if(self.<span class="apidocCodeKeywordSpan">applyUpdate</span>(update))
    emit.call(self, '_update', update) //write to stream.
}

if(source !== this.id) {
  if(this._verify)
    this._verify(update, didVerification)
  else
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.createSeq" id="apidoc.element.crdt.Doc.prototype.createSeq">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>createSeq
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSeq = function (key, val) {
  if(key === '__proto__')
    throw new Error('__proto__ is invalid key')
  return _set(this, key, val, Seq)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports =
function (div, doc) {

var c = 0
div = $(div)

var a = doc.<span class="apidocCodeKeywordSpan">createSeq</span>('set', 'a')
var b = doc.createSeq('set', 'b')
var c = doc.createSeq('set', 'c')

function inplace (initial, cb) {
  var i = $('&lt;input&gt;')
  var done = false
  i.attr('value', initial)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.createSet" id="apidoc.element.crdt.Doc.prototype.createSet">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>createSet
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSet = function (key, val) {
  if(key === '__proto__')
    throw new Error('__proto__ is invalid key')
  return _set(this, key, val, Set)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Doc#createSet (key, value)

Create a `Set` a set is a collection of rows defined by a particular
value on a particular property.

``` js

var cheeses = doc.<span class="apidocCodeKeywordSpan">createSet</span>('type', 'cheese')

```

`key` and `value` must both be strings.

### Doc#createSet (filter)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.get" id="apidoc.element.crdt.Doc.prototype.get">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>get
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (id) {
  if(id === '__proto__') throw new Error('__proto__ is illegal id')
  return this.rows[id] = this.rows[id] || this._add(new Row(id), 'local')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

// remove from all sets that contain row
for (var setId in this.sets) {
  var isSet = setId.indexOf(':') &gt; 0
  var set = this.sets[setId]
  var setContainsRow = isSet &amp;&amp; set &amp;&amp; set.<span class="apidocCodeKeywordSpan">get</span>(row.id)
  if (setContainsRow) set.rm(row)
}

// delete from the doc rows
delete this.rows[id]
row.emit('removed')
this.emit('remove', row)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.history" id="apidoc.element.crdt.Doc.prototype.history">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>history
        <span class="apidocSignatureSpan">(sources)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">history = function (sources) {
  var h = []
  for (var id in this.hist) {
    var hist = this.hist[id]
    for (var k in hist) {
      if(!~h.indexOf(hist[k]) &amp;&amp; Scuttlebutt.filter(hist[k], sources))
        h.push(hist[k])
    }
  }
  return h.sort(order)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          maybe.push(hist[key])
        hist[key] = update
        changed[key] = value
        emit = true
      }
    }
  }
  var h = this.<span class="apidocCodeKeywordSpan">history</span>()
  var self = this
  maybe.forEach(function (e) {
    if(!~h.indexOf(e))
      self.emit('_remove', e)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.rm" id="apidoc.element.crdt.Doc.prototype.rm">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>rm
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rm = function (id) {
  this.set(id, null)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // remove from all sets that contain row
  for (var setId in this.sets) {
    var isSet = setId.indexOf(':') &gt; 0
    var set = this.sets[setId]
    var setContainsRow = isSet &amp;&amp; set &amp;&amp; set.get(row.id)
    if (setContainsRow) set.<span class="apidocCodeKeywordSpan">rm</span>(row)
  }

  // delete from the doc rows
  delete this.rows[id]
  row.emit('removed')
  this.emit('remove', row)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.set" id="apidoc.element.crdt.Doc.prototype.set">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>set
        <span class="apidocSignatureSpan">(id, change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (id, change) {
  if(id === '__proto__')
    throw new Error('__proto__ is illegial id')
  var r = this._add(id, 'local', change)
  return r.set(change)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return h[key][2]
}

Doc.prototype.set = function (id, change) {
  if(id === '__proto__')
    throw new Error('__proto__ is illegial id')
  var r = this._add(id, 'local', change)
  return r.<span class="apidocCodeKeywordSpan">set</span>(change)
}

Doc.prototype.rm = function (id) {
  this.set(id, null)
}

/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.timeUpdated" id="apidoc.element.crdt.Doc.prototype.timeUpdated">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>timeUpdated
        <span class="apidocSignatureSpan">(row, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeUpdated = function (row, key) {
  var h = this.hist[row.id]
  if(!h) return
  return h[key][2]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Doc.prototype.toJSON" id="apidoc.element.crdt.Doc.prototype.toJSON">
        function <span class="apidocSignatureSpan">crdt.Doc.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var j = {}
  for (var k in this.rows) {
    if(this.rows.hasOwnProperty(k))
      j[k] = this.rows[k].state
  }
  return j
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
display: inline-block; \
}                        ';

}

function render (row) {
var html = ''//'&lt;div class=row id="' row.id + '"&gt;\n'
var o = row.<span class="apidocCodeKeywordSpan">toJSON</span>()
for(var k in o) {
  html += '&lt;div class=pair&gt;'
  html += '  &lt;div class=key id="'+   row.id +':key:'+   k +'"&gt;' + k + '&amp;#
x3c;/div&gt;\n'
  html += '  &lt;div class=value id="'+ row.id +':value:'+ k +'"&gt;' + o[k] + '
;&lt;/div&gt;\n'
  html += '&lt;/div&gt;'
}
return html
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.Row" id="apidoc.module.crdt.Row">module crdt.Row</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.Row.Row" id="apidoc.element.crdt.Row.Row">
        function <span class="apidocSignatureSpan">crdt.</span>Row
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Row(id) {
  this.id = id
  this.state = {id: id}
  this.setMaxListeners(Infinity)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Row.super_" id="apidoc.element.crdt.Row.super_">
        function <span class="apidocSignatureSpan">crdt.Row.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.Row.prototype" id="apidoc.module.crdt.Row.prototype">module crdt.Row.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.Row.prototype._set" id="apidoc.element.crdt.Row.prototype._set">
        function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>_set
        <span class="apidocSignatureSpan">(changes, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_set = function (changes, source) {

  //the change is applied by the Doc!
  this.emit('preupdate', changes, source)
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Doc.prototype.add = function (initial) {
var id = initial.id === undefined ? createId() : initial.id
if(id === '__proto__')
  throw new Error('__proto__ is illegial id')
var r = this._add(id, 'local')
r.<span class="apidocCodeKeywordSpan">_set</span>(initial, 'local')
return r
}

Doc.prototype._add = function (id, source, change) {

var doc = this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Row.prototype.get" id="apidoc.element.crdt.Row.prototype.get">
        function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
  if(key)
    return this.state[key]
  return this.state
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

// remove from all sets that contain row
for (var setId in this.sets) {
  var isSet = setId.indexOf(':') &gt; 0
  var set = this.sets[setId]
  var setContainsRow = isSet &amp;&amp; set &amp;&amp; set.<span class="apidocCodeKeywordSpan">get</span>(row.id)
  if (setContainsRow) set.rm(row)
}

// delete from the doc rows
delete this.rows[id]
row.emit('removed')
this.emit('remove', row)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Row.prototype.set" id="apidoc.element.crdt.Row.prototype.set">
        function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>set
        <span class="apidocSignatureSpan">(changes, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (changes, v) {
  if(arguments.length == 2) {
    var k = changes
    if(k === '__proto__')
      return this
    changes = {}
    changes[k] = v
  }

  if(changes !== null &amp;&amp; changes.id &amp;&amp; changes.id !== this.state.id)
    throw new Error('id cannot be changed')

  this._set(changes, 'local')
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return h[key][2]
}

Doc.prototype.set = function (id, change) {
  if(id === '__proto__')
    throw new Error('__proto__ is illegial id')
  var r = this._add(id, 'local', change)
  return r.<span class="apidocCodeKeywordSpan">set</span>(change)
}

Doc.prototype.rm = function (id) {
  this.set(id, null)
}

/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Row.prototype.toJSON" id="apidoc.element.crdt.Row.prototype.toJSON">
        function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.state
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
display: inline-block; \
}                        ';

}

function render (row) {
var html = ''//'&lt;div class=row id="' row.id + '"&gt;\n'
var o = row.<span class="apidocCodeKeywordSpan">toJSON</span>()
for(var k in o) {
  html += '&lt;div class=pair&gt;'
  html += '  &lt;div class=key id="'+   row.id +':key:'+   k +'"&gt;' + k + '&amp;#
x3c;/div&gt;\n'
  html += '  &lt;div class=value id="'+ row.id +':value:'+ k +'"&gt;' + o[k] + '
;&lt;/div&gt;\n'
  html += '&lt;/div&gt;'
}
return html
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Row.prototype.validate" id="apidoc.element.crdt.Row.prototype.validate">
        function <span class="apidocSignatureSpan">crdt.Row.prototype.</span>validate
        <span class="apidocSignatureSpan">(changes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (changes) {
  try {
    this.emit('validate', changes)
    return true
  } catch (e) {
    console.error('validation', e.message)
    return false
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var row = this._add(id, source)
  var hist = this.hist[id] = this.hist[id] || {}
  var emit = false, oldnews = false


  //remember the most recent update from each node.
  //now handled my scuttlebutt.
//  if(!row.<span class="apidocCodeKeywordSpan">validate</span>(changes)) return

  if (changes === null) {

// clean up the history
for(var key in row.state) {
  if(row.state.hasOwnProperty(key)) {
      if(!hist[key] || order(hist[key], update) &lt; 0) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.Seq" id="apidoc.module.crdt.Seq">module crdt.Seq</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.Seq.Seq" id="apidoc.element.crdt.Seq.Seq">
        function <span class="apidocSignatureSpan">crdt.</span>Seq
        <span class="apidocSignatureSpan">(doc, key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Seq(doc, key, val) {
  if(key == '__proto__')
    throw new Error('__proto__ is invalid key')

  Set.call(this, doc, key, val)

  if (typeof key !== 'string') {
    key = null
  }

  var seq = this
  this.on('changes', function (row, changes) {
    if(!changes._sort) return
    sort(seq._array)
    //check if there is already an item with this sort key.
    var prev =
    find(seq._array, function (other) {
      return other != row &amp;&amp; other.get('_sort') == row.get('_sort')
    })

    //nudge it forward if it has the same key.
    if(prev)
      seq.insert(row, prev, seq.next(row))
    else
      seq.emit('move', row)
  })
  this.insert = function (obj, before, after) {

    before = toKey(this.get(before) || '!')
    after  = toKey(this.get(after)  || '~')

    //must get id from the doc,
    //because may be moving this item into this set.
    if('string' === typeof obj)
      obj = doc.rows[obj]

    var _sort =
       between.between(before, after )
     + between.randstr(3) //add a random tail so it's hard
                    //to concurrently add two items with the
                    //same sort.

    var r, changes
    if(obj instanceof Row) {
      r = obj
      changes = {_sort: _sort}
      if (key &amp;&amp; r.get(key) != val) {
        changes[key] = val
      }
      r.set(changes)
    } else {
      obj._sort = _sort
      if (key) {
        obj[key] = val
      }
      r = doc.set(id(obj), obj)
    }
    sort(this._array)
    return r
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.super_" id="apidoc.element.crdt.Seq.super_">
        function <span class="apidocSignatureSpan">crdt.Seq.</span>super_
        <span class="apidocSignatureSpan">(doc, key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Set(doc, key, value) {
  var array = this._array = []
  var rows = this.rows =  {}
  var set = this
  var filter

  if ('function' === typeof key) {
    filter = this.filter = key
    key = null
  } else {
    //DO NOT CHANGE once you have created the set.
    if(key === '__proto__') throw new Error('__proto__ is illegal key')
    this.key = key
    this.value = value
  }

  function add(row) {
    if (rows[row.id]) {
      return
    }

    array.push(row)
    rows[row.id] = row
    set.emit('add', row)

    function remove (_, changed) {
      if ((key &amp;&amp; row.state[key] === value) ||
          (filter &amp;&amp; filter(row.state))
      ) {
        set.emit('changes', row, changed)
        return
      }
      delete rows[row.id]
      var i = array.indexOf(row)
      if(~i) array.splice(i, 1)
      set.emit('changes', row, changed)
      set.emit('remove', row)
      row.removeListener('changes', remove)
    }

    row.on('changes', remove)

  }

  if (!filter) {
    doc.sets.on(key, function (row, changed) {
      if(changed[key] !== value) return
      add(row)
    })
  } else {
    doc.on('create', function (row) {
      if (filter(row.state)) {
        add(row)
      }
    })
  }


  this.rm = this.remove = function (row) {
    row = this.get(row)
    if(!row) return
    if (key) {
      return row.set(key, null)
    } else {
      throw new Error("Set cannot remove rows with arbitary filters")
    }
  }

  for(var id in doc.rows) {
    var row = doc.get(id)
    if (key &amp;&amp; row.get(key) === value) {
      add(row)
    } else if (filter &amp;&amp; filter(row.state)) {
      add(row)
    }
  }

  this.setMaxListeners(Infinity)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.Seq.prototype" id="apidoc.module.crdt.Seq.prototype">module crdt.Seq.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.after" id="apidoc.element.crdt.Seq.prototype.after">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>after
        <span class="apidocSignatureSpan">(obj, after)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">after = function (obj, after) {
  return this.insert(obj, after, this.next(after))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  removed.push(update)
})

s.push({id: 'a', hello:1 })
s.push({id: 'b', hello:2 })
s.push({id: 'c', hello:3 })

s.<span class="apidocCodeKeywordSpan">after</span>('a', 'b')

var hist = doc.history()

removed.forEach(function (e) {
  t.equal(hist.indexOf(e), -1)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.asArray" id="apidoc.element.crdt.Seq.prototype.asArray">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>asArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asArray = function () {
  return sort(this._array)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.at" id="apidoc.element.crdt.Seq.prototype.at">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>at
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at = function (i) {
  if('__proto__' === i) throw new Error('__proto__ invalid index')
  return this._array[i]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function id(e) {
  return Math.random() &lt; 0.5 ? e : e &amp;&amp; e.id
}

function validateNextPrev(seq) {

  seq.each(function (e, k) {
    a.equal(seq.next(id(e)), seq.<span class="apidocCodeKeywordSpan">at</span>(seq.indexOf(id(e)) + 1))
    a.equal(seq.prev(id(e)), seq.at(seq.indexOf(id(e)) - 1))

    a.equal(seq.prev(id(seq.next(id(e)))), e)
    a.equal(seq.next(id(seq.prev(id(e)))), e)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.before" id="apidoc.element.crdt.Seq.prototype.before">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>before
        <span class="apidocSignatureSpan">(obj, before)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">before = function (obj, before) {
  return this.insert(obj, this.prev(before), before)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var itemId = ui.item.attr('id')
  var i = $(this).children().index(ui.item)
  //update event is emitted when a item is removed from a set.
  //in that case i will be -1.
  //changeSet will detect the correct index, though.
  //if item is not already in correct position, move
  if(~i &amp;&amp; seq.indexOf(itemId) !== i)
    seq.<span class="apidocCodeKeywordSpan">before</span>(itemId, ui.item.next().attr('id'))
}

el.sortable({
  connectWith: '.sortable',
  receive: change,
  update: change
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.first" id="apidoc.element.crdt.Seq.prototype.first">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
  return this._array[0]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Seq.prototype.at = function (i) {
  if('__proto__' === i) throw new Error('__proto__ invalid index')
  return this._array[i]
}

Seq.prototype.unshift = function (obj) {
  return this.insert(obj, '!', this.<span class="apidocCodeKeywordSpan">first</span>())
}

Seq.prototype.push = function (obj) {
  return this.insert(obj, this.last(), '~')
}

Seq.prototype.length = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.indexOf" id="apidoc.element.crdt.Seq.prototype.indexOf">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (obj) {
  return this._array.indexOf('string' == typeof obj ? this.rows[obj] : obj)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        emit = true
      }
  }
}

// remove from all sets that contain row
for (var setId in this.sets) {
  var isSet = setId.<span class="apidocCodeKeywordSpan">indexOf</span>(':') &gt; 0
  var set = this.sets[setId]
  var setContainsRow = isSet &amp;&amp; set &amp;&amp; set.get(row.id)
  if (setContainsRow) set.rm(row)
}

// delete from the doc rows
delete this.rows[id]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.last" id="apidoc.element.crdt.Seq.prototype.last">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  return this._array[this._array.length - 1]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Seq.prototype.unshift = function (obj) {
  return this.insert(obj, '!', this.first())
}

Seq.prototype.push = function (obj) {
  return this.insert(obj, this.<span class="apidocCodeKeywordSpan">last</span>(), '~')
}

Seq.prototype.length = function () {
  return this._array.length
}

Seq.prototype.pop = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.length" id="apidoc.element.crdt.Seq.prototype.length">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">length = function () {
  return this._array.length
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

a.strictEqual(seq.last().id,  C.id)

var _C = seq.pop()

a.strictEqual(_C, C)
try {
a.equal(seq.<span class="apidocCodeKeywordSpan">length</span>(), 2)
} catch (e) {
  console.error(doc.history())
  throw e
}
var _A = seq.shift()

a.strictEqual(_A, A)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.next" id="apidoc.element.crdt.Seq.prototype.next">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>next
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (key) {
  key = toKey(this.get(key) || '!')
  return max(this._array, function (M, m) {
    if(toKey(m) &gt; key)
      return M ? toKey(m) &lt; toKey(M) : true
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prev =
find(seq._array, function (other) {
  return other != row &amp;&amp; other.get('_sort') == row.get('_sort')
})

//nudge it forward if it has the same key.
if(prev)
  seq.insert(row, prev, seq.<span class="apidocCodeKeywordSpan">next</span>(row))
else
  seq.emit('move', row)
  })
  this.insert = function (obj, before, after) {

before = toKey(this.get(before) || '!')
after  = toKey(this.get(after)  || '~')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.pop" id="apidoc.element.crdt.Seq.prototype.pop">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  return this.remove(this.last())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a.equal(seq.first(), A)

console.log(seq.toJSON())
seq.push(C)

a.strictEqual(seq.last().id,  C.id)

var _C = seq.<span class="apidocCodeKeywordSpan">pop</span>()

a.strictEqual(_C, C)
try {
a.equal(seq.length(), 2)
} catch (e) {
  console.error(doc.history())
  throw e
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.prev" id="apidoc.element.crdt.Seq.prototype.prev">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>prev
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prev = function (key) {
  key = toKey(this.get(key) || '~')
  //find the greatest item that is less than `key`.
  //since the list is kept in order,
  //a binary search is used.
  //think about that later
  return max(this._array, function (M, m) {
    if(toKey(m) &lt; key)
      return M ? toKey(m) &gt; toKey(M) : true
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Seq.prototype.asArray = function () {
  return sort(this._array)
}

Seq.prototype.before = function (obj, before) {
  return this.insert(obj, this.<span class="apidocCodeKeywordSpan">prev</span>(before), before)
}

Seq.prototype.after = function (obj, after) {
  return this.insert(obj, after, this.next(after))
}

Seq.prototype.first = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.push" id="apidoc.element.crdt.Seq.prototype.push">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>push
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (obj) {
  return this.insert(obj, this.last(), '~')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else {
var maybe = []
for(var key in changes) {
  if(changes.hasOwnProperty(key)) {
    var value = changes[key]
    if(!hist[key] || order(hist[key], update) &lt; 0) {
      if(hist[key] &amp;&amp; !~maybe.indexOf(hist[key]))
        maybe.<span class="apidocCodeKeywordSpan">push</span>(hist[key])
      hist[key] = update
      changed[key] = value
      emit = true
    }
  }
}
var h = this.history()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.shift" id="apidoc.element.crdt.Seq.prototype.shift">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
  return this.remove(this.first())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a.strictEqual(_C, C)
try {
a.equal(seq.length(), 2)
} catch (e) {
  console.error(doc.history())
  throw e
}
var _A = seq.<span class="apidocCodeKeywordSpan">shift</span>()

a.strictEqual(_A, A)
a.equal(seq.length(), 1)

/*
  if two users insert a item into the same place concurrently
  it will get the same sort.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Seq.prototype.unshift" id="apidoc.element.crdt.Seq.prototype.unshift">
        function <span class="apidocSignatureSpan">crdt.Seq.prototype.</span>unshift
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (obj) {
  return this.insert(obj, '!', this.first())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/*seq.on('move', function (row) {
  console.log('MOVE', row.toJSON(), seq.indexOf(row))
})*/

var A = seq.push({id: 'a', type: 'thing', what: 3})
var B = seq.push({id: 'b', type: 'thing', what: 4})
var C = seq.<span class="apidocCodeKeywordSpan">unshift</span>({id: 'c', type: 'thing', what: 2})

a.equal(seq.first(), C)
a.equal(seq.last(),  B)
a.equal(seq.indexOf(id(A)), 1)

seq.rm({id: 'c'})
a.equal(seq.first(), A)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.Set" id="apidoc.module.crdt.Set">module crdt.Set</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.Set.Set" id="apidoc.element.crdt.Set.Set">
        function <span class="apidocSignatureSpan">crdt.</span>Set
        <span class="apidocSignatureSpan">(doc, key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Set(doc, key, value) {
  var array = this._array = []
  var rows = this.rows =  {}
  var set = this
  var filter

  if ('function' === typeof key) {
    filter = this.filter = key
    key = null
  } else {
    //DO NOT CHANGE once you have created the set.
    if(key === '__proto__') throw new Error('__proto__ is illegal key')
    this.key = key
    this.value = value
  }

  function add(row) {
    if (rows[row.id]) {
      return
    }

    array.push(row)
    rows[row.id] = row
    set.emit('add', row)

    function remove (_, changed) {
      if ((key &amp;&amp; row.state[key] === value) ||
          (filter &amp;&amp; filter(row.state))
      ) {
        set.emit('changes', row, changed)
        return
      }
      delete rows[row.id]
      var i = array.indexOf(row)
      if(~i) array.splice(i, 1)
      set.emit('changes', row, changed)
      set.emit('remove', row)
      row.removeListener('changes', remove)
    }

    row.on('changes', remove)

  }

  if (!filter) {
    doc.sets.on(key, function (row, changed) {
      if(changed[key] !== value) return
      add(row)
    })
  } else {
    doc.on('create', function (row) {
      if (filter(row.state)) {
        add(row)
      }
    })
  }


  this.rm = this.remove = function (row) {
    row = this.get(row)
    if(!row) return
    if (key) {
      return row.set(key, null)
    } else {
      throw new Error("Set cannot remove rows with arbitary filters")
    }
  }

  for(var id in doc.rows) {
    var row = doc.get(id)
    if (key &amp;&amp; row.get(key) === value) {
      add(row)
    } else if (filter &amp;&amp; filter(row.state)) {
      add(row)
    }
  }

  this.setMaxListeners(Infinity)

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
it relys on the CRDT deciding to emit stream on next tick.
and emptying the queue.

(those are the two bugs I discovered writing this)
*/


var a = new crdt.<span class="apidocCodeKeywordSpan">Set</span>('set')
var as = crdt.createStream(a)
var b = new crdt.Set('set')
var bs = crdt.createStream(b)

function rand(of) {
var i = Math.floor(Math.random() * (of.length || of))
return of[i] || i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Set.super_" id="apidoc.element.crdt.Set.super_">
        function <span class="apidocSignatureSpan">crdt.Set.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.Set.prototype" id="apidoc.module.crdt.Set.prototype">module crdt.Set.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.Set.prototype.asArray" id="apidoc.element.crdt.Set.prototype.asArray">
        function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>asArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asArray = function () {
  return this._array
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Set.prototype.each" id="apidoc.element.crdt.Set.prototype.each">
        function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>each
        <span class="apidocSignatureSpan">(iter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (iter) {
  return this._array.forEach(iter)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
function id(e) {
  return Math.random() &lt; 0.5 ? e : e &amp;&amp; e.id
}

function validateNextPrev(seq) {

  seq.<span class="apidocCodeKeywordSpan">each</span>(function (e, k) {
    a.equal(seq.next(id(e)), seq.at(seq.indexOf(id(e)) + 1))
    a.equal(seq.prev(id(e)), seq.at(seq.indexOf(id(e)) - 1))

    a.equal(seq.prev(id(seq.next(id(e)))), e)
    a.equal(seq.next(id(seq.prev(id(e)))), e)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Set.prototype.forEach" id="apidoc.element.crdt.Set.prototype.forEach">
        function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>forEach
        <span class="apidocSignatureSpan">(iter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (iter) {
  return this._array.forEach(iter)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          changed[key] = value
          emit = true
        }
      }
    }
    var h = this.history()
    var self = this
    maybe.<span class="apidocCodeKeywordSpan">forEach</span>(function (e) {
      if(!~h.indexOf(e))
        self.emit('_remove', e)
    })
  }

//  probably, there may be mulitple sets that listen to the same key,
//  but activate on different values...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Set.prototype.get" id="apidoc.element.crdt.Set.prototype.get">
        function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>get
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (id) {
  if(!arguments.length)
    return this.array
  if(id === '__proto__') throw new Error('__proto__ is invalid id')
  return (
      'string' === typeof id ? this.rows[id]
    : 'number' === typeof id ? this.rows[id]
    : id &amp;&amp; id.id            ? this.rows[id.id]
    :                          null
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

// remove from all sets that contain row
for (var setId in this.sets) {
  var isSet = setId.indexOf(':') &gt; 0
  var set = this.sets[setId]
  var setContainsRow = isSet &amp;&amp; set &amp;&amp; set.<span class="apidocCodeKeywordSpan">get</span>(row.id)
  if (setContainsRow) set.rm(row)
}

// delete from the doc rows
delete this.rows[id]
row.emit('removed')
this.emit('remove', row)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Set.prototype.has" id="apidoc.element.crdt.Set.prototype.has">
        function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>has
        <span class="apidocSignatureSpan">(row)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (row) {
  return this.get(row)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       return clearTimeout(timer)

    help.randomUpdates(Math.random() &gt; 0.5 ? doc : hoc)
  }, 0)

  var it =  require('it-is').style('colour')
  process.on('exit', function () {
    it(doc.history()).<span class="apidocCodeKeywordSpan">has</span>(hoc.history())
    it(hoc.history()).has(doc.history())
    a.deepEqual(doc.toJSON(), hoc.toJSON())
    it(consistent).ok()
    t.end()
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Set.prototype.onEach" id="apidoc.element.crdt.Set.prototype.onEach">
        function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>onEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEach = function (callback) {
  this.forEach(callback)
  this.on("add", callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
doc.add({id: 'b', type: 'thing', what: 5})
doc.add({id: 'a', type: 'other', what: 7})
doc.add({id: 'c', type: 'thing', what: 9})

var set = doc.createSet("type", "thing")
var states = []

set.<span class="apidocCodeKeywordSpan">onEach</span>(function (row, state) {
  console.log(state)
  states.push(row.state)
})

a.deepEqual(states, [
  { id: 'b', type: 'thing', what: 5 },
  { id: 'c', type: 'thing', what: 9 }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.Set.prototype.toJSON" id="apidoc.element.crdt.Set.prototype.toJSON">
        function <span class="apidocSignatureSpan">crdt.Set.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this._array.map(function (e) {
    return e.state
  }).sort(function (a, b) {
    return between.strord(a._sort || a.id, b._sort || b.id)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
display: inline-block; \
}                        ';

}

function render (row) {
var html = ''//'&lt;div class=row id="' row.id + '"&gt;\n'
var o = row.<span class="apidocCodeKeywordSpan">toJSON</span>()
for(var k in o) {
  html += '&lt;div class=pair&gt;'
  html += '  &lt;div class=key id="'+   row.id +':key:'+   k +'"&gt;' + k + '&amp;#
x3c;/div&gt;\n'
  html += '  &lt;div class=value id="'+ row.id +':value:'+ k +'"&gt;' + o[k] + '
;&lt;/div&gt;\n'
  html += '&lt;/div&gt;'
}
return html
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.super_" id="apidoc.module.crdt.super_">module crdt.super_</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.super_.super_" id="apidoc.element.crdt.super_.super_">
        function <span class="apidocSignatureSpan">crdt.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.filter" id="apidoc.element.crdt.super_.filter">
        function <span class="apidocSignatureSpan">crdt.super_.</span>filter
        <span class="apidocSignatureSpan">(update, sources)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (update, sources) {
  var ts = update[1]
  var source = update[2]
  return (!sources || !sources[source] || sources[source] &lt; ts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Doc.prototype.history = function (sources) {
  var h = []
  for (var id in this.hist) {
    var hist = this.hist[id]
    for (var k in hist) {
      if(!~h.indexOf(hist[k]) &amp;&amp; Scuttlebutt.<span class="apidocCodeKeywordSpan">filter</span>(hist[k], sources))
        h.push(hist[k])
    }
  }
  return h.sort(order)
}

function _set(self, key, val, type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.timestamp" id="apidoc.element.crdt.super_.timestamp">
        function <span class="apidocSignatureSpan">crdt.super_.</span>timestamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timestamp() {
<span class="apidocCodeCommentSpan">  /**
  Returns NOT an accurate representation of the current time.
  Since js only measures time as ms, if you call `Date.now()`
  twice quickly, it's possible to get two identical time stamps.
  This function guarantees unique but maybe inaccurate results
  on each call.
  **/
</span>  //uncomment this wen
  var time = Date.now()
  //time = ~~ (time / 1000)
  //^^^uncomment when testing...

  /**
  If time returned is same as in last call, adjust it by
  adding a number based on the counter.
  Counter is incremented so that next call get's adjusted properly.
  Because floats have restricted precision,
  may need to step past some values...
  **/
  if (_last === time)  {
    do {
      adjusted = time + ((_count++) / (_count + 999))
    } while (adjusted === _adjusted)
    _adjusted = adjusted
  }
  // If last time was different reset timer back to `1`.
  else {
    _count = 1
    adjusted = time
  }
  _adjusted = adjusted
  _last = time
  return adjusted
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.updateIsRecent" id="apidoc.element.crdt.super_.updateIsRecent">
        function <span class="apidocSignatureSpan">crdt.super_.</span>updateIsRecent
        <span class="apidocSignatureSpan">(update, sources)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateIsRecent = function (update, sources) {
  var ts = update[1]
  var source = update[2]
  return (!sources || !sources[source] || sources[source] &lt; ts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.crdt.super_.prototype" id="apidoc.module.crdt.super_.prototype">module crdt.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.crdt.super_.prototype._update" id="apidoc.element.crdt.super_.prototype._update">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>_update
        <span class="apidocSignatureSpan">(update)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_update = function (update) {
  //validated when it comes into the stream
  var ts = update[1]
  var source = update[2]

  //if this message is old for it's source, ignore it. it's out of
  //order. each node must emit it's changes in order!
  //emit an 'old_data' event because i'll want to track how many
  //unnecessary messages are sent.

  var latest = this.sources[source]
  if(latest &amp;&amp; latest &gt;= ts)
    return emit.call(this, 'old_data', update), false

  this.sources[source] = ts

  var self = this
  function didVerification (err, verified) {

    // I'm not sure how what should happen if a async verification
    // errors. if it's an key not found - that is a verification fail,
    // not a error. if it's genunie error, really you should queue and
    // try again? or replay the message later
    // -- this should be done my the security plugin though, not scuttlebutt.

    if(err)
      return emit.call(self, 'error', err)

    if(!verified)
      return emit.call(self, 'unverified_data', update)

    if(self.applyUpdate(update))
      emit.call(self, '_update', update) //write to stream.
  }

  if(source !== this.id) {
    if(this._verify)
      this._verify(update, didVerification)
    else
      didVerification(null, true)
  } else {
    if(this._sign) {
      //could make this async easily enough.
      update[3] = this._sign(update)
    }
    didVerification(null, true)
  }

  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var emit = EventEmitter.prototype.emit

sb.applyUpdate = dutyOfSubclass
sb.history      = dutyOfSubclass

sb.localUpdate = function (trx) {
this.<span class="apidocCodeKeywordSpan">_update</span>([trx, timestamp(), this.id])
return this
}

sb._update = function (update) {
//validated when it comes into the stream
var ts = update[1]
var source = update[2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.applyUpdate" id="apidoc.element.crdt.super_.prototype.applyUpdate">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>applyUpdate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dutyOfSubclass() {
  throw new Error('method must be implemented by subclass')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // check if this message is older than
  // the value we already have.
  // do nothing if so
  // emit an 'old_data' event because i'll want to track how many
  // unnecessary messages are sent.

  if(self.<span class="apidocCodeKeywordSpan">applyUpdate</span>(update))
    emit.call(self, '_update', update) //write to stream.
}

if(source !== this.id) {
  if(this._verify)
    this._verify(update, didVerification)
  else
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.clone" id="apidoc.element.crdt.super_.prototype.clone">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var A = this
  var B = new (A.constructor)
  B.setId(A.id) //same id. think this will work...

  A._clones = (A._clones || 0) + 1

  var a = A.createStream({wrapper: 'raw'})
  var b = B.createStream({wrapper: 'raw'})

  //all updates must be sync, so make sure pause never happens.
  a.pause = b.pause = function noop(){}

  streamDone(b, function () {
    A._clones--
    emit.call(A, 'unclone', A._clones)
  })

  a.pipe(b).pipe(a)
  //resume both streams, so that the new instance is brought up to date immediately.
  a.resume()
  b.resume()

  return B
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		// Single tag
		if ( (parsed = rsingleTag.exec( data )) ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
		return jQuery.merge( [],
			(parsed.cacheable ? jQuery.<span class="apidocCodeKeywordSpan">clone</span>( parsed.fragment ) : parsed.fragment).childNodes );
	},

	parseJSON: function( data ) {
		if ( !data || typeof data !== "string") {
			return null;
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.createReadStream" id="apidoc.element.crdt.super_.prototype.createReadStream">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>createReadStream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReadStream = function (opts) {
  opts = opts || {}
  opts.writable = false; opts.readable = true
  return this.createStream(opts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
createSets('#sets', docs.todo)
})


/*
function sync(doc, name) {
function write () {
  doc.<span class="apidocCodeKeywordSpan">createReadStream</span>({end: false}) //track changes forever
    .pipe(kv.put(name))
}
kv.has(name, function (err) {
  if(err) { //the doc is new
    doc.sync = true
    return write()
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.createStream" id="apidoc.element.crdt.super_.prototype.createStream">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>createStream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createStream = function (opts) {
  var self = this
  //the sources for the remote end.
  var sources = {}, other
  var syncSent = false, syncRecv = false

  this._streams ++

  opts = opts || {}
  var d = duplex()
  d.name = opts.name
  var outer = serializer(opts &amp;&amp; opts.wrapper)(d)
  outer.inner = d

  d.writable = opts.writable !== false
  d.readable = opts.readable !== false

  syncRecv   = !d.writable
  syncSent   = !d.readable

  var tail = opts.tail !== false //default to tail=true

  function start (data) {
    //when the digest is recieved from the other end,
    //send the history.
    //merge with the current list of sources.
    if (!data || !data.clock) {
        d.emit('error');
        return d._end()
    }

    sources = data.clock

    i.each(self.history(sources), function (data) {d._data(data)})

    //the _update listener must be set after the history is queued.
    //otherwise there is a race between the first client message
    //and the next update (which may come in on another stream)
    //this problem will probably not be encountered until you have
    //thousands of scuttlebutts.

    self.on('_update', onUpdate)

    d._data('SYNC')
    syncSent = true
    //when we have sent all history
    outer.emit('header', data)
    outer.emit('syncSent')
    //when we have recieved all histoyr
    //emit 'synced' when this stream has synced.
    if(syncRecv) outer.emit('sync'), outer.emit('synced')
    if(!tail) d._end()
  }

  d
    .on('_data', function (data) {
      //if it's an array, it's an update.
      if(Array.isArray(data)) {
        //check whether we are accepting writes.
        if(!d.writable)
          return
        if(validate(data))
          return self._update(data)
      }
      //if it's an object, it's a scuttlebut digest.
      else if('object' === typeof data &amp;&amp; data)
        start(data)
      else if('string' === typeof data &amp;&amp; data == 'SYNC') {
        syncRecv = true
        outer.emit('syncRecieved')
        if(syncSent) outer.emit('sync'), outer.emit('synced')
      }
    }).on('_end', function () {
      d._end()
    })
    .on('close', function () {
      self.removeListener('_update', onUpdate)
      self.removeListener('dispose', dispose)
      //emit the number of streams that are remaining...
      //this will be used for memory management...
      self._streams --
      emit.call(self, 'unstream', self._streams)
    })

  if(opts &amp;&amp; opts.tail === false) {
    outer.on('sync', function () {
      process.nextTick(function () {
        d._end()
      })
    })
  }
  function onUpdate (update) { //value, source, ts
    if(!validate(update) || !u.filter(update, sources))
      return

    d._data(update)

    //really, this should happen before emitting.
    var ts = update[1]
    var source = update[2]
    sources[source] = ts
  }

  function dispose () {
    d.end()
  }

  var outgoing = { id : self.id, clock : self.sources }

  if (opts &amp;&amp; opts.meta) outgoing.meta = opts.meta

  if(d.readable) {
    d._data(outgoing)
    if(!d.writable &amp;&amp; !opts.clock)
      start({clock:{}})

  } else if (opts.sendClock) {
    //send my current clock.
    //so the other side knows what to send
    d._data(outgoing)
  }

  self.once('dispose', dispose)

  return outer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.sync             = sync
exports.Set              = require('./set')
exports.Seq              = require('./seq')

exports.Doc = exports

function sync(a, b) {
var as = a.<span class="apidocCodeKeywordSpan">createStream</span>()
var bs = b.createStream()
return as.pipe(bs).pipe(as)
}


exports.createStream = function (doc, opts) {
return doc.createStream(opts)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.createWriteStream" id="apidoc.element.crdt.super_.prototype.createWriteStream">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>createWriteStream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWriteStream = function (opts) {
  opts = opts || {}
  opts.writable = true; opts.readable = false
  return this.createStream(opts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  kv.has(name, function (err) {
    if(err) { //the doc is new
      doc.sync = true
      return write()
    }
    var stream = kv.get(name)
    stream.once('end', write)
      .pipe(doc.<span class="apidocCodeKeywordSpan">createWriteStream</span>())
  })
}

sync(docs.todo, 'TODO2-')
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.dispose" id="apidoc.element.crdt.super_.prototype.dispose">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
  emit.call(this, 'dispose')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.history" id="apidoc.element.crdt.super_.prototype.history">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>history
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dutyOfSubclass() {
  throw new Error('method must be implemented by subclass')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          maybe.push(hist[key])
        hist[key] = update
        changed[key] = value
        emit = true
      }
    }
  }
  var h = this.<span class="apidocCodeKeywordSpan">history</span>()
  var self = this
  maybe.forEach(function (e) {
    if(!~h.indexOf(e))
      self.emit('_remove', e)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.localUpdate" id="apidoc.element.crdt.super_.prototype.localUpdate">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>localUpdate
        <span class="apidocSignatureSpan">(trx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">localUpdate = function (trx) {
  this._update([trx, timestamp(), this.id])
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.rows[id]

var r = id instanceof Row ? id : new Row(id)
this.rows[r.id] = r

function track (changes, source) {
  //console.log(changes, source)
  doc.<span class="apidocCodeKeywordSpan">localUpdate</span>([r.id, changes])
}

r.on('preupdate', track)

r.on('remove', function () {
  r.removeAllListeners('preupdate')
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.crdt.super_.prototype.setId" id="apidoc.element.crdt.super_.prototype.setId">
        function <span class="apidocSignatureSpan">crdt.super_.prototype.</span>setId
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setId = function (id) {
  if('__proto__' === id) throw new Error('__proto__ is invalid id')
  if(id == null) throw new Error('null is not invalid id')
  this.id = id
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if(!(this instanceof Scuttlebutt)) return new Scuttlebutt(opts)
  var id = 'string' === typeof opts ? opts : opts &amp;&amp; opts.id
  this.sources = {}
  this.setMaxListeners(Number.MAX_VALUE)
  //count how many other instances we are replicating to.
  this._streams = 0
  if(opts &amp;&amp; opts.sign &amp;&amp; opts.verify) {
    this.<span class="apidocCodeKeywordSpan">setId</span>(opts.id || opts.createId())
    this._sign   = opts.sign
    this._verify = opts.verify
  } else {
    this.setId(id || u.createId())
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>